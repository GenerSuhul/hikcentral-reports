{"ast":null,"code":"import * as XLSX from 'xlsx';\nconst REQUIRED_HEADERS = ['Departamento', 'Grupo de asistencia', 'Nombre', 'Fecha', 'Hora real del registro de entrada', 'Hora real de registro de salida', 'Grabación de asistencia', 'Duración de la pausa', 'Registros de descansos', 'Periodo de tiempo'];\nconst normalizeHeader = header => {\n  return header.toLowerCase().replace(/\\s+/g, ' ').trim();\n};\nexport const parseExcelFile = async file => {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.onload = e => {\n      try {\n        const data = new Uint8Array(e.target.result);\n        const workbook = XLSX.read(data, {\n          type: 'array'\n        });\n        const sheetName = workbook.SheetNames[0];\n        const worksheet = workbook.Sheets[sheetName];\n        let headerRowIndex = -1;\n        let headers = [];\n\n        // Iterate through rows to find the header row\n        const range = XLSX.utils.decode_range(worksheet['!ref']);\n        for (let R = range.s.r; R <= range.e.r; ++R) {\n          const currentRowHeaders = [];\n          for (let C = range.s.c; C <= range.e.c; ++C) {\n            const cellAddress = XLSX.utils.encode_cell({\n              r: R,\n              c: C\n            });\n            const cell = worksheet[cellAddress];\n            if (cell && cell.v) {\n              currentRowHeaders.push(normalizeHeader(String(cell.v)));\n            }\n          }\n          const foundAllRequired = REQUIRED_HEADERS.every(reqHeader => currentRowHeaders.some(h => h.includes(normalizeHeader(reqHeader))));\n          if (foundAllRequired) {\n            headerRowIndex = R;\n            headers = currentRowHeaders;\n            break;\n          }\n        }\n        if (headerRowIndex === -1) {\n          throw new Error('No se encontró la fila de encabezado válida con todas las columnas requeridas.');\n        }\n\n        // Map normalized headers to original headers for data extraction\n        const headerMap = {};\n        for (let C = range.s.c; C <= range.e.c; ++C) {\n          const cellAddress = XLSX.utils.encode_cell({\n            r: headerRowIndex,\n            c: C\n          });\n          const cell = worksheet[cellAddress];\n          if (cell && cell.v) {\n            const normalized = normalizeHeader(String(cell.v));\n            const original = String(cell.v);\n            headerMap[normalized] = original;\n          }\n        }\n\n        // Extract data starting from the row after the header\n        const jsonData = XLSX.utils.sheet_to_json(worksheet, {\n          header: 1,\n          range: headerRowIndex + 1,\n          // Start parsing from the row after the header\n          raw: false // Keep original formatting for dates/times\n        });\n        const processedData = [];\n        jsonData.forEach((row, rowIndex) => {\n          const record = {};\n          let isValidRow = true;\n          REQUIRED_HEADERS.forEach(reqHeader => {\n            const normalizedReqHeader = normalizeHeader(reqHeader);\n            let foundColumn = false;\n            for (const normalizedCol in headerMap) {\n              if (normalizedCol.includes(normalizedReqHeader)) {\n                const originalColName = headerMap[normalizedCol];\n                record[reqHeader] = row[headers.indexOf(normalizedCol)]; // Use index from normalized headers\n                foundColumn = true;\n                break;\n              }\n            }\n            if (!foundColumn) {\n              isValidRow = false; // Missing a required column for this row\n            }\n          });\n          if (isValidRow && Object.keys(record).length > 0) {\n            processedData.push(record);\n          }\n        });\n        resolve(processedData);\n      } catch (error) {\n        reject(error);\n      }\n    };\n    reader.onerror = error => {\n      reject(error);\n    };\n    reader.readAsArrayBuffer(file);\n  });\n};\nexport const extractBranchCode = department => {\n  if (!department) return null;\n  const parts = department.split('>');\n  if (parts.length > 1) {\n    return parts[parts.length - 1].trim();\n  }\n  return null;\n};","map":{"version":3,"names":["XLSX","REQUIRED_HEADERS","normalizeHeader","header","toLowerCase","replace","trim","parseExcelFile","file","Promise","resolve","reject","reader","FileReader","onload","e","data","Uint8Array","target","result","workbook","read","type","sheetName","SheetNames","worksheet","Sheets","headerRowIndex","headers","range","utils","decode_range","R","s","r","currentRowHeaders","C","c","cellAddress","encode_cell","cell","v","push","String","foundAllRequired","every","reqHeader","some","h","includes","Error","headerMap","normalized","original","jsonData","sheet_to_json","raw","processedData","forEach","row","rowIndex","record","isValidRow","normalizedReqHeader","foundColumn","normalizedCol","originalColName","indexOf","Object","keys","length","error","onerror","readAsArrayBuffer","extractBranchCode","department","parts","split"],"sources":["C:/Users/itagr/project/src/utils/excelParser.js"],"sourcesContent":["import * as XLSX from 'xlsx';\n\nconst REQUIRED_HEADERS = [\n  'Departamento',\n  'Grupo de asistencia',\n  'Nombre',\n  'Fecha',\n  'Hora real del registro de entrada',\n  'Hora real de registro de salida',\n  'Grabación de asistencia',\n  'Duración de la pausa',\n  'Registros de descansos',\n  'Periodo de tiempo'\n];\n\nconst normalizeHeader = (header) => {\n  return header.toLowerCase().replace(/\\s+/g, ' ').trim();\n};\n\nexport const parseExcelFile = async (file) => {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n\n    reader.onload = (e) => {\n      try {\n        const data = new Uint8Array(e.target.result);\n        const workbook = XLSX.read(data, { type: 'array' });\n        const sheetName = workbook.SheetNames[0];\n        const worksheet = workbook.Sheets[sheetName];\n\n        let headerRowIndex = -1;\n        let headers = [];\n\n        // Iterate through rows to find the header row\n        const range = XLSX.utils.decode_range(worksheet['!ref']);\n        for (let R = range.s.r; R <= range.e.r; ++R) {\n          const currentRowHeaders = [];\n          for (let C = range.s.c; C <= range.e.c; ++C) {\n            const cellAddress = XLSX.utils.encode_cell({ r: R, c: C });\n            const cell = worksheet[cellAddress];\n            if (cell && cell.v) {\n              currentRowHeaders.push(normalizeHeader(String(cell.v)));\n            }\n          }\n\n          const foundAllRequired = REQUIRED_HEADERS.every(reqHeader =>\n            currentRowHeaders.some(h => h.includes(normalizeHeader(reqHeader)))\n          );\n\n          if (foundAllRequired) {\n            headerRowIndex = R;\n            headers = currentRowHeaders;\n            break;\n          }\n        }\n\n        if (headerRowIndex === -1) {\n          throw new Error('No se encontró la fila de encabezado válida con todas las columnas requeridas.');\n        }\n\n        // Map normalized headers to original headers for data extraction\n        const headerMap = {};\n        for (let C = range.s.c; C <= range.e.c; ++C) {\n          const cellAddress = XLSX.utils.encode_cell({ r: headerRowIndex, c: C });\n          const cell = worksheet[cellAddress];\n          if (cell && cell.v) {\n            const normalized = normalizeHeader(String(cell.v));\n            const original = String(cell.v);\n            headerMap[normalized] = original;\n          }\n        }\n\n        // Extract data starting from the row after the header\n        const jsonData = XLSX.utils.sheet_to_json(worksheet, {\n          header: 1,\n          range: headerRowIndex + 1, // Start parsing from the row after the header\n          raw: false // Keep original formatting for dates/times\n        });\n\n        const processedData = [];\n        jsonData.forEach((row, rowIndex) => {\n          const record = {};\n          let isValidRow = true;\n\n          REQUIRED_HEADERS.forEach(reqHeader => {\n            const normalizedReqHeader = normalizeHeader(reqHeader);\n            let foundColumn = false;\n            for (const normalizedCol in headerMap) {\n              if (normalizedCol.includes(normalizedReqHeader)) {\n                const originalColName = headerMap[normalizedCol];\n                record[reqHeader] = row[headers.indexOf(normalizedCol)]; // Use index from normalized headers\n                foundColumn = true;\n                break;\n              }\n            }\n            if (!foundColumn) {\n              isValidRow = false; // Missing a required column for this row\n            }\n          });\n\n          if (isValidRow && Object.keys(record).length > 0) {\n            processedData.push(record);\n          }\n        });\n\n        resolve(processedData);\n\n      } catch (error) {\n        reject(error);\n      }\n    };\n\n    reader.onerror = (error) => {\n      reject(error);\n    };\n\n    reader.readAsArrayBuffer(file);\n  });\n};\n\nexport const extractBranchCode = (department) => {\n  if (!department) return null;\n  const parts = department.split('>');\n  if (parts.length > 1) {\n    return parts[parts.length - 1].trim();\n  }\n  return null;\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}